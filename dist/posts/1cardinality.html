<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Bug Eraser Data Structures in Typescript</title>
    <meta name="Description" content="Author: Marc Coquand" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <header class="pb2 mh3 mt4-ns mw7-ns  pb5-ns mh5-ns dark-gray">
      <h3 class="f6 gotham upcase ttu f mid-gray w5 fw3 tracked">
        <a href="/" class="link dark-gray b hover-moon-gray">Marc Coquand</a>
        <b>/</b> Article
      </h3>
    </header>
    <article class="article dark-gray pb4 pb6-ns mh3">
      <div class="dashed-list f3 pb3 fw5 mw6-ns auto ">
        <h1 class="firamono ttu tracked-mega f2 pb5-ns fw7 lh-copy">
          Bug Eraser Data Structures in Typescript
        </h1>
        <hr />
        <p class="fw7 f3 pb0 pt3-ns firamono mid-gray tracked-mega">2019-02-03</p>
        <p>The choices of data structures can have a big impact on our software. For example, should we represent our list of users as a hash map, array or stack? There are multiple aspects to take into account when choosing, such as performance. Choosing the wrong one makes it easier to introduce bugs into our software. This is what I will be demonstrating today, along with a tool how you can check manually if you have the right data structure.</p>
<p>Say we want to create a program. The specification says this program will use three colors: blue, red and green. As we are good developers, we start of writing the types. We create an interface to represent our data type.</p>
<pre><code>interface NaiveColor {
    isBlue: boolean;
    isRed: boolean;
    isGreen: boolean;
}</code></pre>
<p>Now, we can represent a color as follows.</p>
<pre><code>const blue: NaiveColor = {
    isBlue: true,
    isRed: false,
    isGreen: false
}</code></pre>
<p>All good and well but what about this value?</p>
<pre><code>const imImpossible: NaiveColor = {
    isBlue: true,
    isRed: true,
    isGreen: false
}</code></pre>
<p>Our specification specified three different colors: red, green and blue. <code>imImpossible</code> seems to be both blue and red at the same time. Our choice of representation for color has made it possible for <em>invalid data</em> to exist. This is a potential source of bugs. How else might we have represented colors? By using Union types.</p>
<pre><code>type GoodColor = Blue | Green | Red</code></pre>
<p>With this type, representing a color that is both red and blue at the same time is impossible. By choosing a different data structure, we have made it impossible to create <em>invalid data</em>. Why invalid data is impossible is because GoodColor's <em>cardinality</em> matches the amount of valid values of the colors we are trying to represent. What is cardinality? Cardinality of a type is a measure of the amount of values of a type are possible. Color has three possible values: Blue, Green and Red. We therefore say that <code>cardinality(Color)=3</code>.</p>
<p>Now what about <code>NaiveColor</code>, what cardinality does it have? Let us first look at the following type</p>
<pre><code>type NaiveColorPrim = [boolean, boolean, boolean]</code></pre>
<p>A boolean can have two possible values: true and false, thus <code>cardinality(boolean) == 2</code>. To calculate <code>NaiveColorPrim</code>'s cardinality, we multiply the cardinality of each of it's members. I.E.</p>
<pre><code>cardinality(NaiveColorPrim) =
cardinality(boolean) ×
cardinality(boolean) ×
cardinality(boolean) =
2×2×2=8</code></pre>
<p>Same goes for the interface <code>NaiveColor</code>. These types, or interfaces, are usually called <em>product type</em>, since it's cardinality is the product of all the cardinalities of each of it's members. If you are not convinced, try writing down all possible values of <code>NaiveColorPrim</code>. In Typescript, there is a separation between types and interfaces. In this article we consider them all to be types, since an interface can be represented as a tuple of all it's members.</p>
<p>Since we know that the amount of valid representations of colors were 3 and that cardinality of <code>NaiveColor</code> is 8, we can deduce that <code>NaiveColor</code> allows for <em>invalid data</em>. Invalid data can be a source of errors and bugs.</p>
<p>There are product types, described above and there are also sum types, such as <code>GoodColor</code>. Another example of a sum type is the type <code>MaybeBool</code>.</p>
<pre><code>type MaybeBool = boolean | Void;</code></pre>
<p><code>MaybeBool</code> can either be true, false or Void. And since it is a union type with two members, the cardinality is the cardinality of each of it's memebers.</p>
<pre><code>cardinality(MaybeBool) =
cardinality(boolean) + cardinality(Void) =
2+1=3</code></pre>
<p>So we call sum types as sum types because they're the sum of the cardinalities of all their members. Product types are called product types because they are the product of all their members, intuitive right?</p>
<p>Some other primitive types that often come up are strings and numbers, whose cardinalities we both represent as ∞, to indicate that their cardinality is large. Remember that cardinality(1+∞)≠∞. Different sizes of infinity matters!</p>
<h2 id="cardinality-in-practice-a-more-difficult-problem">Cardinality in practice, a more difficult problem</h2>
<p>Say we want to create a simple application that loads some data and displays it. The application starts of by loading in information from a source and then displays it to the user. If it fails it displays an error. How should we structure this applications state?</p>
<p>We do not have a lot of information but there are already things we know are needed in the data model.</p>
<ul>
<li>We have a state where data is being loaded.</li>
<li>If downloaded successfully, we load the main state with the data.</li>
<li>If it fails, we need to display an error.</li>
</ul>
<p>So already we can start to reason about the cardinality of our applications state. It has three different states: loading, failure and loaded. We do not know about the cardinality of the data, so let us assume it is ∞. We can represent errors as a string, thus the cardinality of errors should also be ∞. We also note that the amount of possible errors and the amount of possible data are not dependant on each other. We also have a state loading, which since it only has one value, is 1. Thus we can guess that the cardinality should have a form of 1+∞+∞. This means that that the following solution is not ideal.</p>
<pre><code>interface NaiveState {
    loadingError: string | undefined ;
    isLoading: boolean;
    data: Data | undefined;
}</code></pre>
<p>Why? The cardinality of <code>NaiveState</code> is</p>
<pre><code>cardinality(loadingError) = ∞ + 1
cardinality(isLoading) = 2
cardinality(data) = ∞ + 1

cardinality(NaiveState) =
cardinality(loadingError) × cardinality(isLoading) × cardinality(data) =
(∞+1)×2×(∞+1)</code></pre>
<p>It is a product type, not a sum type. Also the cardinality of each factor seems to be higher than desired. It is easy to conjure up a state that actually should be impossible to happen! Look at the following example.</p>
<pre><code>const state : NaiveState = {
    loadingError = &quot;data did not load&quot;,
    isLoading: false,
    data = {...}
}

function displayState(state : NaiveState) {
    if (state.isLoading) {
        displayLoading()
    } else if (state.loadingError) {
        console.log(state.error)
    } else if(data) {
        displayData()
    }
}</code></pre>
<p>It has given us an error, saying data did not load. However it has also loaded some data. This means that we have an invalid state. Somewhere in our code there is a bug!</p>
<p>Let us look at another solution. What if we start off with the following discriminated union type:</p>
<pre><code>type State = Loading | Loaded | Error</code></pre>
<p>Now we three possible states and the cardinality will be of the form</p>
<pre><code>cardinality(State) =
cardinality(Loading) + cardinality(Loaded) + cardinality(Error)</code></pre>
<p>Let us implement the interfaces for State.</p>
<pre><code>
interface Loading {
    kind: &quot;loading&quot;;
}

interface Loaded {
    kind: &quot;loaded&quot;;
    data: Data
}

interface Error {
    kind: &quot;error&quot;;
    message: string
}
</code></pre>
<p>The field &quot;kind&quot; has a cardinality of 1 since it's simply a given value. Enable Strict null checks in Typescript to enforce this. Now we can calculate the cardinality of State.</p>
<pre><code>cardinality(Loading) = 1
cardinality(Loaded) = 1×cardinality(Data) = ∞
cardinality(Error) = 1×cardinality(Error) = ∞
cardinality(State) = 1+∞+∞</code></pre>
<p>Much better, by taking a closer look at the problem we were solving and using cardinality we could reason that we had the wrong representation for our state. We could then take an alternative implementation and reason that that was a better representation of our state and use cardinality as a tool to reason as to why.</p>
        <a href="/" class="f3 article-size link skobeloff hover-moon-gray fw4"
          >‹ View more posts</a
        >
      </div>
    </article>
  </body>
</html>
