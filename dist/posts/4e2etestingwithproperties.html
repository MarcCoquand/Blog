<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Rapid E2E-testing</title>
    <meta name="Description" content="Author: Marc Coquand" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <header class="pb2 mh3 mt4-ns mw7-ns  pb5-ns mh5-ns dark-gray">
      <h3 class="f6 gotham upcase ttu f mid-gray w5 fw3 tracked">
        <a href="/" class="link dark-gray b hover-moon-gray">Marc Coquand</a>
        <b>/</b> Article
      </h3>
    </header>
    <article class="article dark-gray pb4 pb6-ns mh3">
      <div class="dashed-list f3 pb3 fw5 mw6-ns auto ">
        <h1 class="firamono ttu tracked-mega f2 pb5-ns fw7 lh-copy">
          Rapid E2E-testing
        </h1>
        <hr />
        <p class="fw7 f3 pb0 pt3-ns firamono mid-gray tracked-mega">2019-05-02</p>
        <p>To ensure that our program works correctly there are three layers that need to check: the integration layer, unit layer and entire application, so called End2End-test. Common wisdom is that the higher up you move on these layers the more expensive it gets, so unit tests are cheap, integration tests more expensive and E2E-tests most expensive. Thus the recommendation is that you write mostly unit tests, then less integration tests and even less End2End-tests. This is called the testing pyramid.</p>
<p>Testing environments can be difficult. But using property-based testing we can find more obscure concurrency bugs easier. When we do integration tests for environments using property based testing we create a symbolic representation that we test against the effectful representation. We then assert that after a random set of actions the symbolic and the effectful representation have the same properties. This means that afterwards when we have asserted they behave the same we can swap one for the other, ensuring that in practice our mock is the same as the actual implementation.</p>
<p>We use End2End-test to give us confidence that the program works as it should from start to finish. They also allow us to make sure that we have completed the objectives in the specification. In practice, these tests are difficult since we need to spin up mocked environment with fake services running in the background. This means that it can be tempting to just skip these tests all together.</p>
<p>However does it really have to be this way? If the integration tests have ensured that the symbolic and actual implementation have the same properties, we can actually substitute one for the other. This means that if every environment has been integration tested, the End2End-tests can be ran using the symbolic environment. We do not need to worry about strange concurrency bugs happening, or to clarify, it is not the goal of the End2End-test anymore. That responsibility is in the integration test.</p>
<p>So knowing that, say we have a web application with a CRUD REST api and a client using react/redux . We want to test the client side and ensure it's correct and meets the specification. We have two borders that talk to the real world, the REST api and react that is displaying html to the browser. So to cover the borders we have to do two integration tests.</p>
<p>To test the CRUD api, we hide the CRUD api behind an interface (inversion of control). Afterwards we instance that interface also with a symbolic representation, using a hashmap as our store. By generating a list of actions done, we check that if the prequisities for the CRUD api and the hashmap are the same, after performing the action they have the same property. For example if we have performed insert item with <code>itemId</code> then <code>get(itemId)</code> should return <code>item</code> for both the symbolic and CRUD api.</p>
<p>Next we need to integration test the html code consisting of a view function. A view function is defined as <code>view : State -&gt; Html Action</code>. We can create a symbolic representation of this by creating a function which takes a state and returns a list of actions, <code>viewSymbolic : State -&gt; [Actions]</code>. Now the property we need to test is that, for a function <code>actions</code> that extracts the actions a view can dispatch.</p>
<pre><code>forall State s. actions(view(s)) === viewSymbolic(s)
    where actions : Html Action -&gt; [Action]</code></pre>
<p>Now we can test the entire application. If we use the TEA architecture we have one big state and a sum type for our actions. We have a tested interface for the REST API that we can substitute with the symbolic representation to use with the reducer. Now it's easy to test actions on the reducer and ensure whatever properties we want to hold (for example the user can't login and then reach login page). If we want, we can also create tests for user stories, like given the list of actions <code>buy=[GOTOLOGIN, SENDLOGINDETAILS, ADDTOCART,FILLINDETAILS, BUY]</code> and an initial state <code>s</code> if we reduce it we should end up with a goal state <code>s'</code> and at each step should the action be a member of <code>viewSymbolic(currentState)</code>.</p>
<p>Doing this we can create really rapid E2E-tests that don't need an entire environment. We will also quicker find concurrency bug and their source by testing at the borders of our applications rather than testing the entire thing. The E2E-test works more as a way for us to ensure that the specification is fulfilled.</p>
        <a href="/" class="f3 article-size link skobeloff hover-moon-gray fw4"
          >â€¹ View more posts</a
        >
      </div>
    </article>
  </body>
</html>
