<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>SOLID, Interface Segregation Principle</title>
    <meta name="Description" content="Author: Marc Coquand" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <header class="pb2 mh3 mt4-ns mw7-ns  pb5-ns mh5-ns dark-gray">
      <h3 class="f6 gotham upcase ttu f mid-gray w5 fw3 tracked">
        <a href="/" class="link dark-gray b hover-moon-gray">Marc Coquand</a>
        <b>/</b> Article
      </h3>
    </header>
    <article class="article dark-gray pb4 pb6-ns mh3">
      <div class="dashed-list f3 pb3 fw5 mw6-ns auto ">
        <h1 class="firamono ttu tracked-mega f2 fw7 lh-copy">SOLID, Interface Segregation Principle</h1>
        <hr />
        <p class="fw7 f3 pb0 pt3-ns pb3-ns firamono mid-gray tracked-mega">
          2019-07-16
        </p>
        <p>This the third part of a series on SOLID principles applied to functional principles. Today's topic is Interface Segregation Principle. The principle states</p>
<p><q>No client should be forced to depend on methods it does not use. The general idea is that you want to split big interfaces to smaller, specific ones.</q></p>
<p>In Functional programming, we can use type classes and separate those into smaller type classes as a form of dependency inversion and call that interface segregation principle but I think that is not exciting. Instead, I will translate the principle to <q>Interface Segregation Principle states that the smallest set of data should be used for each function to work</q>. How does this definition relate to interface segregation principle? To figure this out, we need to think of types as sets.</p>
<h3 id="types-as-sets">Types as Sets</h3>
<p>A type, such as Int or Bool, can be thought of as a set of possible values it can yield. So for example <code>type Bool = {True, False}</code>, <code>type Int = {-∞,...,-2,-1,0,1,2...,+∞}</code>. In set theory, the <em>cardinality</em> of a type is the amount of values it can yield. So for Bool the cardinality is 2 since it can either yield True or False. For Int the cardinality is ∞.</p>
<p>This becomes useful when picking the data representation for our structures. For example how might we represent Colors, here are some suggestions:</p>
<pre><code>type Color = Blue | Red | Green
-- alternatively
type Color2 = {Blue: Bool, Red : Bool, Green: Bool}</code></pre>
<p>Which representation is best? Well let's look at the second representation <code>Color2</code>. This representation works fine for values such as <code>{Blue = True, Red = False, Green = False}</code>, but what about <code>{Blue = True, Red= True, Green = False}</code>? We have created a value that should be impossible! The reason is because the <em>cardinality</em> of <code>Color2</code> is <code>2×2×2=8</code>. You might have heard the name product types for records, the reason is because their cardinality is the product of their members. Meanwhile the type <code>Color</code> only has <code>1+1+1=3</code> possible values it can be (Red, green or blue). For this reason Color is called a sum type, as the cardinality is the sum of it's members. By choosing the right data representation, Color, we can greatly reduce the amount of bugs in our software.</p>
<p>The full table for cardinalities is as follows (taken from <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types#fn:answer">here</a>).</p>
<table>
<colgroup>
<col width="27%" />
<col width="4%" />
<col width="68%" />
</colgroup>
<thead>
<tr class="header">
<th>Haskell</th>
<th>Math</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>data void</code></td>
<td>0</td>
<td>Impossible to construct</td>
</tr>
<tr class="even">
<td><code>data () = ()</code></td>
<td>1</td>
<td>Only one value possible</td>
</tr>
<tr class="odd">
<td><code>data Bool = True | False</code></td>
<td>2</td>
<td>Sum of two values, hence why<br> these are sometimes called union<br> types</td>
</tr>
<tr class="even">
<td><code>data Maybe a = Just a | Nothing</code></td>
<td>a+1</td>
<td>Sum of whatever a is and 1</td>
</tr>
<tr class="odd">
<td><code>data Either = Right a | Left b</code></td>
<td>a+b</td>
<td></td>
</tr>
<tr class="even">
<td><code>data (a,b) = (a,b)</code></td>
<td>a×b</td>
<td>Both types cardinality combined.<br> Hence why these are called<br> product types.</td>
</tr>
<tr class="odd">
<td><code>a -&gt; b</code></td>
<td>b^a</td>
<td></td>
</tr>
</tbody>
</table>
<p>Not only can we represent Int, Bool and Color as sets. Advanced types such as <code>type Computation a b = a -&gt; b</code> can also be represented as sets. The cardinality of Computation is <code>|a|^|b|</code>.</p>
<p>This has implications for Interface Segregation principle. Given a user library where we can store and fetch users, one might write</p>
<pre><code>data = IUserRepo {
    getUser : Id -&gt; IO User,
    storeUser : User -&gt; Id -&gt; IO ()
    }

getUserEndpoint : IUserRepo -&gt; Request -&gt; Response
-- ... Do stuff</code></pre>
<p><code>getUserEndpoint</code> will never use storeUser, but it is still included in the getUserEndpoint as an argument. It's cardinality becomes</p>
<pre><code>|getUser| × |storeUser| = |Id|^|(IO User)| × |User|^|Id|^1</code></pre>
<p>In Haskell, the abstraction for <code>IO a</code> is <code>IO a = Realworld -&gt; (a, Realworld)</code> so the cardinality is <code>(a × Realworld) ^ Realworld</code> where <code>Realworld</code> would be all the bits of the system (so a very big number). The cardinality of () is 1. If instead <code>IUserRepo</code> is segregated into two, the cardinality of <code>getUserEndpoint</code> is greatly reduced.</p>
<pre><code>data IGetUser = {getUser : Id -&gt; IO User}
data IStoreUser = {storeUser : User -&gt; Id -&gt; IO ()}

getUserEndpoint : IGetUser -&gt; Request -&gt; Response
-- ... Do stuff</code></pre>
<p>By splitting them up, we have greatly reduced the amount of possible values that the <code>getUserEndpoint</code> can represent and also segregated the interfaces so that <code>IStoreUser</code> can be modified without <code>IGetUser</code> being affected.</p>
<p>Cardinality is not a perfect tool for analysis due to many sets being infinite. But it can be a useful tool for glossing over which data structure to use.</p>
<p>So in Functional programming, the interface segregation principle can be broadened to apply to all values and types, not just interfaces. So in that sense that principles has been extended to apply to all data we deal with and how we choose to represent it.</p>
        <a href="/" class="f3 article-size link skobeloff hover-moon-gray fw4"
          >‹ View more posts</a
        >
      </div>
    </article>
  </body>
</html>
