<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Refinement-driven application development</title>
    <meta name="Description" content="Author: Marc Coquand" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Scheherazade:400,700"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <header class="pb2 mh3 mt4-ns mw7-ns  pb5-ns mh5-ns dark-gray">
      <h3 class="f6 gotham upcase ttu f mid-gray w5 fw3 tracked">
        <a href="/" class="link dark-gray b hover-moon-gray">Marc Coquand</a>
        <b>/</b> Article
      </h3>
    </header>
    <article class="article dark-gray pb4 pb6-ns mh3">
      <div class="dashed-list f3 pb3 fw5 mw6-ns auto ">
        <h1 class="firamono ttu tracked-mega f2 pb6-ns fw7 lh-copy">
          Refinement-driven application development
        </h1>
        <hr />
        <p class="fw4 f3 pb0 pt3-ns firamono mid-gray tracked-mega">2019-05-05</p>
        <p>Over the last months I have been working on a method for building applications. There is probably someone who has done this somewhere else but as far I know no one has done this so far. I coin the term refinement-driven development to allow us to be buzzword-friendly. Based around constructing software via stepwise-refinements, the method using functional programming constructs, dependency injection and property-based testing. A refinement-driven approach sets out to achieve the following:</p>
<ol style="list-style-type: decimal">
<li>All forms of testing should be straightforward, including unit, integration and E2E-testing. Testing should be human-first approach, meaning in practice that we can go from user stories to writing tests for those user stories.</li>
<li>Architecture should allow us to easily add new environment. This approach allows us to create a web application and then port it to mobile. In fact using this approach to build a web application the last thing we would implement is the html itself.</li>
<li>Strike a balance between maintainability, being bug-free and budget constrains. This method lies somewhere between current industry standards and formal methods/formal verification in it's rigor. The method gives us flexibility to be fast in certain areas but adds room to create further assurance in places where critical.</li>
<li>The method should be agile and responsive to new requirements.</li>
<li>It should allow for easier testing of concurrent systems and microservices.</li>
<li>It should be as simple as possible.</li>
<li>Following it should naturally lead to SOLID-principles.</li>
<li>It should be optimization friendly, as well as ensuring that more verification can be done later it also ensures that performance optimizations can be done.</li>
<li>It is somewhat language agnostic. Requirement from the language is supporting functional programming constructs and property-based testing. You need to have sum types or variants or discriminated unions, records and higher-order functions. Languages I know that support this are Typescript, ReasonML, Haskell, Purescript and F#. Having the same language for both front-end and back-end makes this method even more powerful.</li>
</ol>
<p>The approach is close to what we find in formal methods, specifically refinements hence the name. The core idea is combining a formal method approach to software development with property-based testing to ensure our refinements are consistent with our simpler model without having to write difficult, error prone, proofs.</p>
<p>Property-based testing is a new form of testing where we generate data for our functions and ensure that properties hold. The simplest example is that we can ensure that <code>reverse(reverse(list)) === list</code>. The property-based check will generate lists to try to find the simplest counter-example.</p>
<p>Property-based testing is not perfect however. Finding invariants to test is not obvious for the uninitiated. Property-based testing gets even harder if you have not built your code around it from the start, like unit testing.</p>
<p>A core strength of property-based testing is that we can use it to test environments in isolation. That is we can test that two microservices work in isolation for bugs that would before only show up when doing integration tests. Doing so allows us to use a mocked environment for testing the microservices together.</p>
<p>This all thanks to the idea of refinements. A refinement is defined as follows. For any specification <em>P</em> (our problem), <em>P</em> is <em>refined</em> by a specification <em>S</em>, if and only if, <em>P</em> is satisfied whenever <em>S</em> is satisfied. Formally this means that <code>forall m. P &lt;== S</code>. What does this mean in English? Well it means that, for example, if we have a mocked database and a real database, if every property for the mocked and real one is the same for our model we can swap one out for the other and be sure that the rest of our program behaves the same. This might sound obvious but it has powerful implications for the rest of our software. It means that:</p>
<ol style="list-style-type: decimal">
<li>We can test walking through the application with simple function composition and be sure that if that works it will also work for our mobile application and web application.</li>
<li>We can test for concurrency and parallelism bugs dependent from the environment. We test individual parts of the system for these bugs by using our model and property-based testing. Afterwards we can test the integration of these parts by using the mocked environment.</li>
<li>We can develop our entire application independent of any actual implementation. We can create it without caring about if we should use React or Vue. Or if we should use Postgresql or Mongodb. When the software is done we plug in whatever environment we want. Should we pick the wrong one we can swap it out later, thanks to inversion of control.</li>
</ol>
<h3 id="elm-architecture-as-the-foundation-of-our-application">Elm architecture as the foundation of our application</h3>
<p>The law of refinement is actually quite simple but powerful in practice. It states</p>
<p>Property-based testing means to test that invariants hold. What is an invariant? It is a condition that is true regardless of what data we feed a function. A variant is the opposite, something that varies which is usually data.</p>
        <a href="/" class="f3 article-size link skobeloff hover-moon-gray fw4"
          >â€¹ View more posts</a
        >
      </div>
    </article>
  </body>
</html>
